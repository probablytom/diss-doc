\chapter{Tools Created}
\label{implementation_head}
As previously discussed, the project's development lay in three key areas: 
\begin{enumerate}
    \item Some model to fuzz
    \item Some mechanism by which fuzzing can happen appropriately
    \item Some examples of fuzzing that might represent sociotechnical stress
\end{enumerate}\par

The latter two being tools required to create the first one. Therefore, to test the hypothesis, a fuzzing library and modelling system it could work on were created. 

\section{Modelling System}
\label{model_outline}
The modelling system was designed to make both creating and fuzzing models easy. As no modelling systems in the research phase were found to be adequate for the project, a new one had to be designed from scratch.\par
This modelling system needed to have a few traits. As a result of it being written by hand, and being a full sociotechnical model in programming code, the language used had to be very human readable. In addition, the language needed to have easy and accessible tools for creating fuzzing libraries. Also, this language needed to be easy to create relatively complex models in, so the language itself needed to be easy to use. Lastly, a well known language was a major selling point, as people writing models would need to know the language. In this scenario, the models were being made for the dissertation project, and there was insufficient time to learn a new language for modelling over and above creating the fuzzing libraries. Only one language -- Python -- met these criteria, so Python was the language chosen to create models in. \par%Modelling system goals

Currently, tools such as Eclipse Modelling Framework\cite{EMFManual} can create code from a UML diagram, so basing the models on UML seemed sensible; in the future, large parts of model creation in this format might be automated, because a graphical representation can be converted into a procedural model for the fuzzing technique. As a result of the project's heavy focus on workflow modelling, UML Activity Diagrams\cite{Omg2010} were chosen as a representation of workflow. UML Activity diagrams have long been a common way to represent workflow models\cite{Gogolla2001}. As a result of the simplicity possible in the models created to test the hypothesis, a complete adaptation of the UML specification for Activity Diagrams to Python code was not pursued. Instead, determining how to adapt basic flow structures from Activity Diagrams was all that was required to create sufficiently complex models to test the hypothesis. More complex adaptations of the UML Activity Diagram specification, such as concurrent activity with fork and join notations, is discussed in the Future Work section. \par%Basis in UML Activity Diagrams

\subsection{Layer Model}%Different layers
To separate concerns and make fuzzing safer and easier, two critical concerns were separated in the model creation section: the flow of work, and that work's effect on its sociotechnical environment. \par

\subsubsection{Flow Layers}
It was identified that descriptions of work were generally given on a high level, and broken down to finer detail when probed when models were considered at the beginning of the research. As a result, it made sense to regard certain patterns of work as sub-workflows that are chained together by some overarching workflow. \par

Furthermore, there was no reason why these sub-workflows could not be nested to a fine degree of detail. It was determined that any "flow" of work does not affect the sociotechnical environment in-and-of itself, but that it simply dictates the order in which the effects of sociotechnical work are introduced to a system. At the finest grain of detail for a given model, another component, called "atoms", affect the sociotechnical environment and these are chained together by the flows to create meaningful workflows. \par

A flow of work can also be considered a collection of connected nodes on a UML Activity Diagram. These areas of work are small operations that are, in real life, broken down into smaller tasks, but finer detail is still needed to accurately model the sociotechnical detail\cite{Crabtree2000}. \par

Where this fine detail becomes important is in creating a model structure appropriate for fuzzing. If we want to introduce code fuzzing when actors perform a particular activity, it is important to be able to target that particular activity as a subsection of the whole model and isolate that activity. Such scenarios could be the case where an actor is a newly trained employee and is likely to miss a step in a certain process they were badly trained in. In this case, we might expect them to successfully complete the rest of the model, but to occasionally skip a node in a sociotechnical flow and move straight into its successor. This can be done by isolating the activities a sociotechnical flow is made of, creating each minor activity (the \emph{atoms} described below), and chaining them together into some code which is to be marked as fuzz-able.\par

Flows are to be made from a high-level perspective, and then broken down into sub-components until a model of sufficient detail is constructed. This way, one can construct a model in a natural way: considering the activities people perform on a day-to-day basis and drilling down to finer detail over time. To take the example of the model implemented later in this report, one might describe the agile method of software engineering, after requirements gathering, as:
\begin{itemize}
    \item Implementing features
    \item Unit testing
    \item Integration testing
    \item User acceptance testing
\end{itemize} \par
Which, as a flow, might look like this:
\begin{pyglist}[language = python, encoding = utf8]
def implement_feature():
    make_new_feature()
    create_test_and_code()
    unit_test()
    integration_test()
    user_acceptance_test()
\end{pyglist}

When we break down one of these steps in the larger workflow, we get a more fine-grained view of what "unit testing" entails:
\begin{pyglist}[language = python, encoding = utf8]
def implement_feature():
    make_new_feature()
    create_test_and_code()
    unit_test()
    integration_test()
    user_acceptance_test()

# Descriptions of model created and environment module below
def unit_test():
    run_tests()
    while not environment.resources["unit tests passing"]:
        fix_recent_feature()
        run_tests()
\end{pyglist}\par
Now, if one wanted to mutate unit testing but wanted to assume that feature implementation, integration testing, and user acceptance testing were to be reliably executed, the modeller would only need to mutate the unit\_test\(\) function. \par
In this way, the models are suitable for fuzzing, while keeping the flow of activity easy to read. In addition, models can be edited and maintained easily, as any large blocks of code are indicators that a flow can be broken down to smaller components. \par
\todo{Image showing sections of an activity diagram and how it would transform to flows?}

\subsubsection{Atom Layers}
Atoms are the finest grain of a model's detail. Therefore, if an action cannot be broken down into smaller activities, that action is an atom --- so named because they cannot be broken down further --- and are called by flows to enact change on the sociotechnical environment. \par
The distinction between atoms and flows that makes them separate layers is that flows make calls to other flows or atoms, but \emph{cannot} change the sociotechnical environment. This is because the order itself of an activity does not affect a sociotechnical environment; the actions of actors in a sociotechnical system do. Therefore, atoms are the only level of detail that should affect the sociotechnical environment. \par
When changing a sociotechnical environment, we alter its state, which internally in a simulation is to alter values held -- to write to a variable. However, to read the values in those variables is to make decisions which are informed by the current state of the sociotechnical system. This is necessary for flows. Therefore, we make a distinction between reading from and writing to a variable: \emph{only atoms are allowed to write to sociotechnical state}. Both atoms and flows may read the sociotechnical state. (The above example of a flow does this in evaluating `environment.resources["unit tests passing"]`.)\par
While atoms can change the sociotechnical environment, they should never call another atom. This is because that atom's affects on its environment are specific to the activity it represents; to run another atom after the current atom would represent a small sub-workflow, which is the domain of flows. \par
Doing this separates the concerns of the two layers, which, while useful for fuzzing purposes, also serves to make the systems more maintainable. Any problems with sociotechnical environment would be an issue with the atoms, and any problem with the ordering of activity or flow of action would be an issue with the flows. The concerns can also be split across multiple files, further improving maintainability and making the creation of a system which represents the real world easier. \par
As a result of this distinction, another should be drawn: atoms cannot be mutated. This is because the mutation we enact is on \emph{workflow}, whereas atoms are \emph{activities}. The distinction is similar to that between actions we choose to do and physics itself: we are bound by the laws of physics and cannot change this element of our environment, but we can change the things we do within these laws of physics. Similarly, sociotechnical atoms are the physics of the workflow; they shouldn't be changed, because if one does things in the wrong order or forgets to act in certain ways, it cannot affect the effect it has on its environment. Therefore, every action an actor can perform is its own sociotechnical atom, and an action's affects on its environment do not change. An example of this would be unit testing: if a programmer writes a test, that test is written and is a component of his sociotechnical environment. However, he might forget to write a test; this is a change to his workflow, so it is represented as a mutation in the workflow layer. \todo{REPHRASE?} \par
To extend the above example to include an atom, create\_test\_tdd\(\), too:
\begin{pyglist}[language = python, encoding = utf8]
#An example flow, does not affect environment
def implement_feature():
    make_new_feature()
    create_test_and_code()
    unit_test()
    integration_test()
    user_acceptance_test()

#An example flow, does not affect environment
def unit_test():
    run_tests()
    while not environment.resources["unit tests passing"]:
        fix_recent_feature()
        run_tests()

#An example flow, does not affect environment
def create_test_and_code():
    create_test_tdd()
    add_chunk_tdd()
    
#An example Atom, directly affects environment
def create_test_tdd():
    environment.resources["time"] += 1
    test = dag.Test()
    environment.resources["tests"].append(test)

\end{pyglist}\par
As can be seen, the atom in this example affects the environment of the model in two ways: the activity takes time, incrementing a counter, and a test is created and appended to a list of tests the model is aware of. However, the flows in the model never affect sociotechnical state, and the atom never calls another atom. 

\subsubsection{Creating a model}
The final component of a model is the environment itself. This completes the sociotechnical system, as we only distinguish between the sociotechnical environment and its  \par

\section{Fuzzing Library}
\label{planning_fuzzing_implementation} % Cass points out that I don't mention why I don't use a language other than Python. Worth discussing here
\todo{Rewrite this section!}
The implementation of the fuzzing library was broken down into two distinct parts. \par
The first was a wrapping function that would allow a modeller to determine which of their functions were to be mutated. This was done by employing \emph{decorators}. \emph{Decorators} are a feature of Python that allow for a clean notation to wrap a function in another function. The wrapping function (the decorator) is passed a function object when the original function is called by a program, and is expected to run the original function around some other work or to conditionally run the function if some preconditions were met. This is often employed for URL to controller function routing in web app frameworks like Django. \par%\cite{} django
For our purposes, Django would run a mutated version of the original function, meaning that every time the function was called, the decorator would generate a mutation of that function from some source code. Upon generating this fuzzed version of the function, the decorator would call this rather than the original function, thereby running a variant that simulates the unreliability of human actors in a sociotechnical system, as per the library's requirements. \par
The second section of the library would be the mutation class itself. To do this, inspiration was taken from PyMuTester, which creates an Abstract Syntax Tree from source code and modifies the source for the purposes of analysis. Another reason for continuing to use Python was the availability of an Abstract Syntax Tree library built in to Python, which PyMuTester also used. Where PyMuTester used a Python NodeVisitor to collect information about source, however, we utilised a Python NodeTransformer to edit an abstract syntax tree and return a mutated version. \par%\cite{} pymutester   \cite{} python docs on ast classes?
When creating the NodeTransformer class, originally some mutations were built into the class' activity, with its behaviour selected through some parameter upon execution, and different decorators passing their associated parameters. In a later version, the decision was made to change this design so that the mutation itself was made to be a parameter. This had two effects: 
\begin{enumerate}
    \item A function object was passed as an argument to the decorator, which took a list of Python AST Line objects and returned another list of Python AST Line objects. This meant that the modeller could control the variance introduced precisely, making the tool much more suitable to future use and for powering future work in this area.
    \item With a mutating function passed to the mutator as a parameter, different mutators were no longer needed to specify different mutation types. Therefore, every function to be mutated in the model becomes flagged with a single line before its definition reading "mutate", followed by the type of mutation required.\\This was to increase readability, and also vastly simplify the act of mutating for a modeller.\\It also allows for greater visibility into the mutator's internal structure, as a qualm had with currently available code fuzzing libraries was that the specific activity when mutating a function could feel akin to a black box, and its effect on the code was not always clear.
\end{enumerate}\par

The final implementation of the fuzzing library was therefore two Python classes, one for flagging functions where variance is to be introduced and specifying the format of its mutation, and another for carrying out the editing of the workflow using the mutation specified as a parameter of the former class.\par
The final implementation of the fuzzing library was deemed to meet these requirements, as it: 
\begin{enumerate}  % Do we really want this to be an itemize? (bulleted list)
    \item Allowed for easy and readable mutation specification as one decorator, called \emph{"mutate"}, could be used to specify a function needed to be mutated through a custom defined function
    \item Allowed for flexible mutation on the part of the modeller due to the parametrised mutation behaviour
    \item \emph{Crucially}, real-time mutation due to the mutations being carried out and subsequently executed in the decorator, and that variant function being run rather than the function called.
\end{enumerate} \par