\chapter{Tools Created}
\label{implementation_head}
As previously discussed, the project's development lay in three key areas: 
\begin{enumerate}
    \item Some model to fuzz
    \item Some mechanism by which fuzzing can happen appropriately
    \item Some examples of fuzzing that might represent sociotechnical stress
\end{enumerate}\par

The latter two being tools required to create the first one. Therefore, to test the hypothesis, a fuzzing library and modelling system it could work on were created. 

\section{Modelling System}
\label{model_outline}
The modelling system was designed to make both creating and fuzzing models easy. As no modelling systems in the research phase were found to be adequate for the project, a new one had to be designed from scratch.\par
This modelling system needed to have a few traits. As a result of it being written by hand, and being a full sociotechnical model in programming code, the language used had to be very human readable. In addition, the language needed to have easy and accessible tools for creating fuzzing libraries. Also, this language needed to be easy to create relatively complex models in, so the language itself needed to be easy to use. Lastly, a well known language was a major selling point, as people writing models would need to know the language. In this scenario, the models were being made for the dissertation project, and there was insufficient time to learn a new language for modelling over and above creating the fuzzing libraries. Only one language -- Python -- met these criteria, so Python was the language chosen to create models in. \par%Modelling system goals
Currently, tools such as Eclipse Modelling Framework\cite{EMFManual} can create code from a UML diagram, so basing the models on UML seemed sensible; in the future, large parts of model creation in this format might be automated, because a graphical representation can be converted into a procedural model for the fuzzing technique. As a result of the project's heavy focus on workflow modelling, UML Activity Diagrams\cite{Omg2010} were chosen as a representation of workflow. UML Activity diagrams have long been a common way to represent workflow models\cite{Gogolla2001}. As a result of the simplicity possible in the models created to test the hypothesis, a complete adaptation of the UML specification for Activity Diagrams to Python code was not pursued. Instead, determining how to adapt basic flow structures from Activity Diagrams was all that was required to create sufficiently complex models to test the hypothesis. More complex adaptations of the UML Activity Diagram specification, such as concurrent activity with fork and join notations, is discussed in the Future Work section. \par%Basis in UML Activity Diagrams
\subsection{Layer Model}%Different layers
To separate concerns and make fuzzing safer and easier, two critical concerns were separated in the model creation section: the flow of work, and that work's effect on its sociotechnical environment. \par
\subsubsection{Flow Layers}
It was identified that descriptions of work were generally given on a high level, and broken down to finer detail when probed when models were considered at the beginning of the research. As a result, it made sense to regard certain patterns of work as sub-workflows that are chained together by some overarching workflow. \par
Furthermore, there was no reason why these sub-workflows could not be nested to a fine degree of detail. It was determined that any "flow" of work does not affect the sociotechnical environment in-and-of itself, but that it simply dictates the order in which the effects of sociotechnical work are introduced to a system. At the finest grain of detail for a given model, another component, called "atoms", affect the sociotechnical environment and these are chained together by the flows to create meaningful workflows. \par
A flow of work can also be considered a collection of connected nodes on a UML Activity Diagram. These areas of work are small operations that are, in real life, broken down into smaller tasks, but finer detail is still needed to accurately model the sociotechnical detail\cite{Crabtree2000}. \par
Where this fine detail becomes important is in creating a model structure appropriate for fuzzing. If we want to introduce code fuzzing when actors perform a particular activity, it is important to be able to target that particular activity as a subsection of the whole model and isolate that activity. Such scenarios could be the case where an actor is a newly trained employee and is likely to miss a step in a certain process they were badly trained in. In this case, we might expect them to successfully complete the rest of the model, but to occasionally skip a node in a sociotechnical flow and move straight into its successor. This can be done by isolating the activities a sociotechnical flow is made of, creating each minor activity (the \emph{atoms} described below), and chaining them together into some code which is to be marked as fuzz-able.\par
Flows are to be made from a high-level perspective, and then broken down into sub-components until a model of sufficient detail is constructed. This way, one can construct a model in a natural way: considering the activities people perform on a day-to-day basis and drilling down to finer detail over time. For example, one might describe the waterfall method of software engineering, after requirements gathering, as: 
\begin{itemize}
    \item Implementing features
    \item Unit testing
    \item Integration testing
    \item User acceptance testing
\end{itemize} \par
Which, as a flow, might look like this:
\begin{pyglist}[language = python, encoding = utf8]
def waterfall_implementation():
    implement_features()
    unit_test()
    integration_test()
    ua_test()
\end{pyglist}

%Flows are to be made from the top down
% - Little detail being drilled down to fine-grained detail
% - The lowest level of detail is not broken down further, so it's "atomic"
% - The greater grain of detail is a flow, chaining these "atoms" together. 
% - Any flow or sub-flow should be targetable as a mutatable construct
\subsubsection{Atom Layers}

% - Atoms
% - Flows
% - Unit tests/simple code to execute a model
% - Environment
%A

\subsubsection{Sociotechnical Environment}
% Really just a component of the model
% Explain the one implemented in the example models as an example

\subsubsection{Executing a model}

\section{Fuzzing Library}
\label{planning_fuzzing_implementation} % Cass points out that I don't mention why I don't use a language other than Python. Worth discussing here
\todo{Rewrite this section!}
The implementation of the fuzzing library was broken down into two distinct parts. \par
The first was a wrapping function that would allow a modeller to determine which of their functions were to be mutated. This was done by employing \emph{decorators}. \emph{Decorators} are a feature of Python that allow for a clean notation to wrap a function in another function. The wrapping function (the decorator) is passed a function object when the original function is called by a program, and is expected to run the original function around some other work or to conditionally run the function if some preconditions were met. This is often employed for URL to controller function routing in web app frameworks like Django. \par%\cite{} django
For our purposes, Django would run a mutated version of the original function, meaning that every time the function was called, the decorator would generate a mutation of that function from some source code. Upon generating this fuzzed version of the function, the decorator would call this rather than the original function, thereby running a variant that simulates the unreliability of human actors in a sociotechnical system, as per the library's requirements. \par
The second section of the library would be the mutation class itself. To do this, inspiration was taken from PyMuTester, which creates an Abstract Syntax Tree from source code and modifies the source for the purposes of analysis. Another reason for continuing to use Python was the availability of an Abstract Syntax Tree library built in to Python, which PyMuTester also used. Where PyMuTester used a Python NodeVisitor to collect information about source, however, we utilised a Python NodeTransformer to edit an abstract syntax tree and return a mutated version. \par%\cite{} pymutester   \cite{} python docs on ast classes?
When creating the NodeTransformer class, originally some mutations were built into the class' activity, with its behaviour selected through some parameter upon execution, and different decorators passing their associated parameters. In a later version, the decision was made to change this design so that the mutation itself was made to be a parameter. This had two effects: 
\begin{enumerate}
    \item A function object was passed as an argument to the decorator, which took a list of Python AST Line objects and returned another list of Python AST Line objects. This meant that the modeller could control the variance introduced precisely, making the tool much more suitable to future use and for powering future work in this area.
    \item With a mutating function passed to the mutator as a parameter, different mutators were no longer needed to specify different mutation types. Therefore, every function to be mutated in the model becomes flagged with a single line before its definition reading "mutate", followed by the type of mutation required.\\This was to increase readability, and also vastly simplify the act of mutating for a modeller.\\It also allows for greater visibility into the mutator's internal structure, as a qualm had with currently available code fuzzing libraries was that the specific activity when mutating a function could feel akin to a black box, and its effect on the code was not always clear.
\end{enumerate}\par

The final implementation of the fuzzing library was therefore two Python classes, one for flagging functions where variance is to be introduced and specifying the format of its mutation, and another for carrying out the editing of the workflow using the mutation specified as a parameter of the former class.\par
The final implementation of the fuzzing library was deemed to meet these requirements, as it: 
\begin{enumerate}  % Do we really want this to be an itemize? (bulleted list)
    \item Allowed for easy and readable mutation specification as one decorator, called \emph{"mutate"}, could be used to specify a function needed to be mutated through a custom defined function
    \item Allowed for flexible mutation on the part of the modeller due to the parametrised mutation behaviour
    \item \emph{Crucially}, real-time mutation due to the mutations being carried out and subsequently executed in the decorator, and that variant function being run rather than the function called.
\end{enumerate} \par