\chapter{Research}
\label{research_head}
With regards to the hypothesis of the project, there was not much literature revolving around the introduction of variance to a sociotechnical model, rather than taking variance into account when creating the model. For example, Herrmann \& Loser\cite{Herrmann1999} discuss sociotechnical modelling with inherent vagueness, and while this might be shown to be a useful construct, it doesn't address the problem that sociotechnical modelling with uncertainty of action is difficult to model. Instead, Herrmann & Loser create sociotechnical models using pictorial representations -- but these may be difficult to mutate programmatically. Therefore, a comparison of current methods for representing sociotechnical systems and introducing variance was necessary. \par

\section{Currently existing platforms}
As a result of the desire to create programmatic models to mutate, it was decided that a purely pictographic representation of a sociotechnical system could introduce some complications to the research. In particular, with the project's focus being on the affect of code fuzzing and whether it represents sociotechnical variance, it was decided that a modelling system that lended itself to code fuzzing was the biggest concern. If code fuzzing did lend itself to better modelling social variance in sociotechnical models, then the technique could be applied to other modelling platforms, too. \par

\subsection{KaOS} %TODO
%Goal-oriented model
%Our actors are ultimately trying to fulfil some goal, so surely goal-orientation is what we want?
%Widely used and seemingly popular for academic purposes -- good if we wanted to do future work or get interest in the project!
%KaOS is often used in Requirements Engineering, and we're really interested in workflow modelling, so maybe best to look elsewhere.

\subsection{i*} %TODO
%Actor intent model
%We're putting stress on actors, so this is interesting
%Used for requirements engineering?
%Not really workflow-oriented, which is what we want, but actor orientation is interesting, because we're modelling the actions of people, rather than their goals. Therefore, this tells us something about the system we ultimately want to find/create.

\subsection{YAWL} %TODO
%Actually a workflow language!
%Graphical
%has a multi-platform editor but maybe not best for our purposes

\subsection{Lessons learned} %TODO (What did we learn and how did it influence our model?)



\subsection{Introducing Variance}
\label{Variance_research}
Currently, variance must be introduced to a p

\subsection{Graphical representations and UML}
\label{pictorial}
Pictorial representations of sociotechnical systems can be very human-readable, which makes them suitable candidates for creating a sociotechnical model. Modelling systems such as OBASHI\cite{ObashiMethodology} use graphical representations of sociotechnical systems to build models of business and IT processes, but build these models using dataflow.To contrast, a UML Use Case diagram\cite{Omg2010} models an actor within a larger system to visualise a sociotechnical system. Both models use graphical representations of the systems they model to make the complexity of the model easy for a human to parse, but these models can be difficult for a computer to parse. UML tries to overcome this by being equally readable by a computer: frameworks like the Eclipse Modelling Framework can generate Java code from a UML class diagram, for example\cite{EMFManual}. UML also succeeds in creating a standard for colloquial "flowcharts" by creating well-defined specifications such as the UML Activity Diagram. Therefore, using UML as a format for laying out a sociotechnical system that can be easily created and read by humans, but is also easily computer-parsable, seemed to be an appropriate way to create the programmatic models.


\section{Making the tools}  
\label{planning_head}
Having researched what was already available in the academic and commercial spaces, it was decided after some deliberation that the best option was to define our own modelling system and create our own fuzzing library. 

\subsection{Modelling System}\label{planning_modelling}
\subsubsection{Modelling System Requirements}\label{planning_modelling_requirements}
The modelling system desired had some properties that could not be found in the available alternatives. For example, the models had to be procedural, but also easy to write and maintain. It was decided that, with the work done in software engineering to maximise the maintainability of code, a mainstream and well-documented programming language should be chosen. To that end, and for other reasons discussed below, Python was the candidate of choice for this attempt. \par
The programming language chosen was also to be powerful, because potentially rather complex models would be created with this modelling system. However, Python allowed for this, as can be seen by the large software development projects undertaken in Python. The fact that Python is a very powerful, very portable language that allows for readable codebases at scale was a strong influencing factor when deciding what language would suit the construction of a sociotechnical system. \par% \cite{}, what large software development projects?
Another feature of the models that needed to be implemented was that they must be modular. With Python being a language often chosen for large codebases, and being a language often used to deploy webapps using frameworks such as Django, Python allows for the creation of modules and packages that makes it easy to bring a workflow written for a subsection of a system and integrate it into a larger model of that system. \\It is worth noting that there are problems with this approach. For example, when introducing two systems together, their interaction is a part of the atoms the system defines. However, with each component being created separately, neither system would initially be able to interface to another. Middleware layers for sociotechnical systems are written about in the future work section. \par \par%\cite{} django    \cite{} middleware-layers label

\subsection{Fuzzing Library}\label{planning_fuzzing}
\subsubsection{Fuzzing Library Requirements}\label{planning_fuzzing_requirements}
The fuzzing library desired also had unique properties that made it difficult to find an equivalent for in a commercial or academic setting. \par
The fuzzing library was of particular importance because the main study of the project was on variance in sociotechnical systems. Therefore, the fuzzing library had a particularly strict set of requirements. the fuzzing library needed to have fairly precise control over the activity of the mutations, because the mutations it introduced needed to be representative of sociotechnical stress. Ideally, it would be possible that the mutation testing would not be a black box, so that the exact nature of the sociotechnical stress could be discerned. Therefore, if a custom library was not to be made, then the chosen library would need to be open sourced. \par
It was found that the library would need to be built to spec anyway, because the library needed to generate different mutations on every call to the functions it was fuzzing. This meant that not only would specific parts of the procedural model need to be targeted, but the library would either have to intercept function calls somehow or fuzz the function to randomly select one of many fuzzed versions of itself at execution time. This functionality was \emph{critical}, because human variance in a workflow is to change the behaviour in some random way every time that behaviour is executed. With flows and atoms acting as blueprints for behaviour, these blueprints would need to be altered when enacted, just as in real life, to make a meaningful simulation. No available code fuzzing library could be found that could do fuzzing during the execution of the fuzzed program, so a custom library needed to be built. \par
With the fuzzing library being such a critical part of the research, none of these points could be compromised on. In addition, a custom built library would allow fuzzing methods to adapt and grow as the modelling method matured. Therefore, a custom fuzzing library was made. \par

\label{research_fuzzing}
Because the systems we were interested in creating were to be self-documenting, we chose Python as a language to write our models in. Python's clarity combined with the ease of quickly writing working Python code meant that self-documenting models could be feasibly made. In addition, Python supplied language features such as decorators and a built in Abstract Syntax Tree library that made it an ideal candidate. \par
We therefore set about finding appropriate fuzzing libraries in Python, and found several:
\subsection{Sulley}
\label{fuzzing_sulley}
Sulley is a fuzzing library for Python which is popular for remote application and protocol fuzzing. Sulley alters the protocol by which it inserts data into an application or system, and observes how that application reacts to the altered input, to simulate problems with networks and human users. It is under active development, and is open sourced.\par
While using a popular, open-source library for inspiration when creating our own mutation system, Sulley was inappropriate for our needs.\par
Sulley fuzzes by way of changing protocols and inputs to some system it interacts with. We felt that altering inputs to that system lacked the degree of control that changing workflows directly would provide. Technically, it would be possible to get around this problem by creating models in some remote program that took instructions from some fuzzed input, but we felt that this additional degree of abstraction would lower the self-documenting nature of our models and would be an impractical modelling technique anyway. \par

\subsection{Fusil}
\label{fuzzing_fuzil}
Fusil was another fuzzing library that was investigated. Fusil allows for fuzzing the environment of a python program, which made it appealing to us. While environmental factors impact the sociotechnical model however, these factors are unrelated to the properties Fusil is capable of monitoring. \par
Fusil is able to create mangled files as fuzzed/invalid input to a program, monitors and limits CPU and memory usage, and checks logs for system errors and other signs that a fuzzed program was not functioning correctly under adverse circumstances. This seemed appealing, because monitoring performance under adverse circumstances is precicely our goal in this project. \par
Unfortunately Fusil also did not meet our requirements: it monitors the effect of a change in computational environment on a program, where we are interested in the effect of the change of a social environment on a workflow. While our workflows are being modelled as programs, this does not mean that the workflows themselves would be being altered, so stress on a sociotechnical system still wouldn't be being modelled. Fusil was a further worse choice when taking into account the fact that we would not be able to pinpoint the errors that were being introduced by observing memory and CPU usage, and other computational concerns. \par
Therefore, we could not use Fusil as our fuzzing system of choice. \par

\subsection{MutPy}
\label{fuzzing_mutpy}
From the MutPy package page: %\cite{} mutpy package description at https://pypi.python.org/pypi/MutPy
\begin{displayquote}
MutPy is a mutation testing tool for Python 3.x source code. MutPy supports standard unittest module, generates YAML reports and has colorful output. It’s apply mutation on AST level. You could boost your mutation testing process with high order mutations (HOM) and code coverage analysis.
\end{displayquote}\par
It seemed that MutPy supplied \emph{everything required}. This would be beneficial, but unfortunately, MutPy had a relatively large and complex codebase that made it hard to modify for our needs. In addition, relying on a complex dependency that is designed for unit testing seemed to be a bad approach, as research interests might not align with MutPy's maintainers' in the future. As a result, it might have been necessary to fork their codebase at the time and maintain our own version for research purposes; this approach was not future-proof, and so an alternative approach was deemed necessary. \par
Working in MutPy's favour, however, was that it was a \emph{code fuzzing} rather than protocol fuzzing library. Particularly, it fuzzed source code to a similar end as something like Java's PiTest. This was more in line with our goals, although MutPy still didn't deliver what was required from a cofde fuzzing library for this experiment. \par%\cite{} PiTest at http://pitest.org/

\subsection{PyMuTester}
\label{fuzzing_pymutester}
PyMuTester proved to be the closest to the library required, though it still fell short in some areas. Particularly, PyMuTester did not appear to have many types of mutation it could enact. \par
PyMuTester did not have a large codebase, nor did it have very much functionality to offer, but it offered mutation via an Abstract Syntax Tree editing. The decision was made to study the PyMuTester source as a template for a code fuzzing library of a new design. PyMuTester seemed to be much too immature as a library to base the whole project around, and was last updated in October 2014. However, it did show promise, and gave a basis around which writing a code mutation library could be built, while also taking cues from the more advanced source of MutPy.  \par%\cite{} PyMuTester source at https://github.com/miketeo/PyMuTester       \cite{} MutPy's source at https://bitbucket.org/khalas/mutpy/src


\subsubsection{Modelling System Implementation}\label{planning_modelling_implementation}

% Some stuff about the different layers and how they chain together
% \cite{} obashi


\subsubsection{Fuzzing System Implementation}\label{planning_fuzzing_implementation}
The implementation of the fuzzing library was broken down into two distinct parts. \par
The first was a wrapping function that would allow a modeller to determine which of their functions were to be mutated. This was done by employing \emph{decorators}. \emph{Decorators} are a feature of Python that allow for a clean notation to wrap a function in another function. The wrapping function (the decorator) is passed a function object when the original function is called by a program, and is expected to run the original function around some other work or to conditionally run the function if some preconditions were met. This is often employed for URL to controller function routing in web app frameworks like Django. \par%\cite{} django
For our purposes, Django would run a mutated version of the original function, meaning that every time the function was called, the decorator would generate a mutation of that function from some source code. Upon generating this fuzzed version of the function, the decorator would call this rather than the original function, thereby running a variant that simulates the unreliability of human actors in a sociotechnical system, as per the library's requirements. \par
The second section of the library would be the mutation class itself. To do this, inspiration was taken from PyMuTester, which creates an Abstract Syntax Tree from source code and modifies the source for the purposes of analysis. Another reason for continuing to use Python was the availability of an Abstract Syntax Tree library built in to Python, which PyMuTester also used. Where PyMuTester used a Python NodeVisitor to collect information about source, however, we utilised a Python NodeTransformer to edit an abstract syntax tree and return a mutated version. \par%\cite{} pymutester   \cite{} python docs on ast classes?
When creating the NodeTransformer class, originally some mutations were built into the class' activity, with its behaviour selected through some parameter upon execution, and different decorators passing their associated parameters. In a later version, the decision was made to change this design so that the mutation itself was made to be a parameter. This had two effects: 
\begin{enumerate}
    \item A function object was passed as an argument to the decorator, which took a list of Python AST Line objects and returned another list of Python AST Line objects. This meant that the modeller could control the variance introduced precisely, making the tool much more suitable to future use and for powering future work in this area.
    \item With a mutating function passed to the mutator as a parameter, different mutators were no longer needed to specify different mutation types. Therefore, every function to be mutated in the model becomes flagged with a single line before its definition reading "mutate", followed by the type of mutation required.\\This was to increase readability, and also vastly simplify the act of mutating for a modeller.\\It also allows for greater visibility into the mutator's internal structure, as a qualm had with currently available code fuzzing libraries was that the specific activity when mutating a function could feel akin to a black box, and its effect on the code was not always clear.
\end{enumerate}\par

The final implementation of the fuzzing library was therefore two Python classes, one for flagging functions where variance is to be introduced and specifying the format of its mutation, and another for carrying out the editing of the workflow using the mutation specified as a parameter of the former class.\par
The final implementation of the fuzzing library was deemed to meet these requirements, as it: 
\begin{itemize}  % Do we really want this to be an itemize? (bulleted list)
    \item Allowed for easy and readable mutation specification as one decorator, called \emph{"mutate"}, could be used to specify a function needed to be mutated through a custom defined function
    \item Allowed for flexible mutation on the part of the modeller due to the parametrised mutation behaviour
    \item \emph{Crucially}, real-time mutation due to the mutations being carried out and subsequently executed in the decorator, and that variant function being run rather than the function called.
\end{itemize} \par
