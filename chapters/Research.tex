\chapter{Research}
\label{research_head}
With regards to the hypothesis of the project, there was not much literature revolving around the introduction of variance to a sociotechnical model, rather than taking variance into account when creating the model. For example, Herrmann \& Loser\cite{Herrmann1999} discuss sociotechnical modelling with inherent vagueness, and while this might be shown to be a useful construct, it doesn't address the problem that sociotechnical modelling with uncertainty of action is difficult to model. Instead, Herrmann & Loser create sociotechnical models using pictorial representations -- but these may be difficult to mutate programmatically. Therefore, a comparison of current methods for representing sociotechnical systems and introducing variance was necessary. \par

\section{Modelling System}\label{planning_modelling}
\subsubsection{Modelling System Requirements}\label{planning_modelling_requirements}
The modelling system desired had some properties that could not be found in the available alternatives. For example, the models had to be procedural, but also easy to write and maintain. It was decided that, with the work done in software engineering to maximise the maintainability of code, a mainstream and well-documented programming language should be chosen. To that end, and for other reasons discussed below, Python was the candidate of choice for this attempt. \par
The programming language chosen was also to be powerful, because potentially rather complex models would be created with this modelling system. However, Python allowed for this, as can be seen by the large software development projects undertaken in Python. The fact that Python is a very powerful, very portable language that allows for readable codebases at scale was a strong influencing factor when deciding what language would suit the construction of a sociotechnical system. \par% \cite{}, what large software development projects?
Another feature of the models that needed to be implemented was that they must be modular. With Python being a language often chosen for large codebases, and being a language often used to deploy webapps using frameworks such as Django\cite{Azzopardi2016a}, Python allows for the creation of modules and packages that makes it easy to bring a workflow written for a subsection of a system and integrate it into a larger model of that system. \\It is worth noting that there are problems with this approach. For example, when introducing two systems together, their interaction is a part of the atoms the system defines. However, with each component being created separately, neither system would initially be able to interface to another. Middleware layers for sociotechnical systems are discussed in the future work section.\cref{middleware-layers} \par%\cite{} django    \cite{} middleware-layers label
A lesson learned from the research on i* was that the interactions between different people makes a big difference to the end result of the sociotechnical simulation to be built. Therefore, to simplify the end-product, only one actor should be simulatable at a time in the modelling system that is ultimately created. Any more would add complexity to the project, and one actor should be sufficient for modelling a workflow that can exhibit sociotechnical variance. This limitation will mean that any sociotechnical stress that occurs as a result of interplay between actors cannot be simulated. \par

\subsection{Currently existing platforms}
As a result of the desire to create programmatic models to mutate, it was decided that a purely pictographic representation of a sociotechnical system could introduce some complications to the research. In particular, with the project's focus being on the affect of code fuzzing and whether it represents sociotechnical variance, it was decided that a modelling system that lended itself to code fuzzing was the biggest concern. If code fuzzing did lend itself to better modelling social variance in sociotechnical models, then the technique could be applied to other modelling platforms, too. \par

\subsection{KaOS} %TODO
KaOS is a goal-oriented modelling technique for sociotechnical systems modelling\cite{Werneck2009}. This seemed like an appropriate place to begin, as KaOS is heavily used and cited in the academic community. The actors we model are attempting to achieve or fulfil some goal, so surely this is an appropriate place to start researching current modelling techniques.\par%Goal-oriented model
%Our actors are ultimately trying to fulfil some goal, so surely goal-orientation is what we want?
However, there are some issues with KaOS for the purposes of our models. For one, KaOS is useful if one must elicit software engineering requirements from a client, but in terms of modelling human actors, KaOS is less widely used. Requirements engineering techniques would be inappropriate for a model we intend to fuzz, even if a representation of the goals might also be mutatable. \par 
Ideally these models should be easily verifiable by a human, so either a graphical or human-readable textual format would be good to represent these, but KaOS lends itself well to graphical representations that seemed hard to execute as some simulation. Therefore, while widely taught and used, KaOS doesn't meet our requirements for modelling. \par
%Widely used and seemingly popular for academic purposes -- good if we wanted to do future work or get interest in the project!
%KaOS is often used in Requirements Engineering, and we're really interested in workflow modelling, so maybe best to look elsewhere.

\subsection{i*} %TODO
i* is another technique that, while useful for gaining an insight into some sociotechnical system, is ill-suited to our needs as a result of its requirements engineering background\cite{Werneck2009}. In i*, actors rely on each other for goals and responsibilities to be fulfiled. i* therefore represents a better social model for a system than some of its competitors, and is widely cited and popular in the academic community, similar to KaOS. Both are used in situations as different as software engineering\cite{Almisned2010}, artificial intelligence\cite{VanDiggelen2010}, and even comes up in journals for infectious diseases\cite{Tutorial2007}. \par
%Actor intent model
%We're putting stress on actors, so this is interesting.
As a result of i*'s better social modelling than KaOS, we get a slightly different look a sociotechnical modelling and requirements engineering. However, as widely cited and interesting as i* might be, it suffers the same fundamental flaws that KaOS does, the largest of which being its lack of workflow modelling. It is clear to see that interactions between people is an important component of any sociotechnical modelling platform, however. Due consideration should be given as to the social implications in a sociotechnical model and whether any sociotechnical stresses that arise from the social interaction would be useful for this proof of concept project. \par
%Used for requirements engineering?
%Not really workflow-oriented, which is what we want, but actor orientation is interesting, because we're modelling the actions of people, rather than their goals. Therefore, this tells us something about the system we ultimately want to find/create.

\subsection{YAWL} %TODO
YAWL was particularly interesting because of its focus on workflow. YAWL, which stands for Yet Another Workflow Language\cite{TerHofstede2010}, is a workflow modelling platflorm with its own tools, which are sophisticated and multi-platform. The creators of YAWL also have interests in areas such as \(\pi\)-calculus\cite{Aalst2004}, which makes YAWL interesting for the additional reason that it has some mathematical backing in its representation of workflows. With this said, the lead authors have also published work stating that workflows are much more than simple \(\pi\)-calculus processes\cite{Aalst2004}. \par
While workflow is our main concern when searching for candidates to perform fuzzing on, YAWL is largely constructed with a graphical tool, making it difficult to find things to mutate. Ergo, YAWL would be inappropriate as a candidate for fuzzable systems. However, it does get us closer to the modelling system we require, and shows that there is some academic interest in workflow-oriented modelling systems. \par
%Actually a workflow language!
%Graphical
%has a multi-platform editor but maybe not best for our purposes

\subsection{OBASHI}
OBASHI\cite{ObashiMethodology} is a modellings system that focuses on business processes instead of sociotechnical models. However, OBASHI's business process modelling techniques focus on dataflow, meaning that systems have states that get changed as a simulation occurs. OBASHI also focuses on simplicity in its models, which is something that would be required by a sociotechnical modelling framework to ensure that the models created for this project would be at least moderately accurate representations of the systems as a whole.\par
While little academic literature is available on OBASHI due to its strong commercial focus, it supports an idea of hierarchy between different components of a system with its layered Dataflow Analysis Views\cite{ObashiMethodology}. Given that dataflow and workflow have clear correlations, it might be prudent for a fuzzable sociotechnical platform to seperate its own concerns by using layer models. \par 
Indeed, focusing away from the academic perspective, many modelling systems are used commercially that are not open to scientific analysis. Few pieces of academic literature exist at all for OBASHI, despite its 15 year existence. Therefore, it might be prudent to look to the commercial sector and analyse what works in the practically minded business world to create mappings of systems. One might rely on the common market to select mapping systems that are reliable and functional, so long-lasting methods with interest from industry might give insights into better sociotechnical models in the future. For the purposes of this project, such a detailed modelling system would not be worth the time required to build it, as the hypothesis to be tested centres around code fuzzing. \par
%Obashi isn't strictly for sociotechnical models, it focuses on business processes
%Focus on dataflow and connections between components of a large system. 
%Beginning to be picked up by industry and manual printed by The Stationary Office, so government endorsements, but it's not directly related to the dissertation. 
%Nevertheless, it's actually widely used in the commercial world, so something's working. What can we learn?

\subsection{Code Fuzzing for Sociotechnical Variance}
Little academic research appears to have been done on programmatically inserting sociotechnical variance. A little work has been done into systems for \emph{Punctuated Socio-Technical Information System Change model}s\cite{Lyytinen2008}, but this appears to refer more to the way information systems alter over time and less to do with the study of uncertainty in information systems. \par
Other research has been done into the management of organisational uncertainty\cite{Grote2004}\cite{Herrmann1999}, which appears to be ideal for the task at hand. Unfortunately, no sociotechnical simulations with uncertainty injected into the models created could be found. \par
Therefore, while sociotechnical modelling is now a well-established field with competing methodologies and sociotechnical uncertainty has also been a research subject since as early as 1976\cite{Susman1976}, no programmatic sociotechnical modelling has been documented which models sociotechnical stress as a component of that model. Therefore, the hypothesis of the project is clear; that is, to construct such a system and attempt to verify that sociotechnical stress can be introduced to the system by means of code fuzzing. \par

%\subsection{Lessons learned} %TODO (What did we learn and how did it influence our model?)

\subsection{Introducing Variance}
\label{Variance_research}
\todo{FINISH THIS}
Currently, variance must be introduced to a p 

\subsection{Graphical representations and UML}
\label{pictorial}
Pictorial representations of sociotechnical systems can be very human-readable, which makes them suitable candidates for creating a sociotechnical model. Modelling systems such as OBASHI\cite{ObashiMethodology} use graphical representations of sociotechnical systems to build models of business and IT processes, but build these models using dataflow.To contrast, a UML Use Case diagram\cite{Omg2010} models an actor within a larger system to visualise a sociotechnical system. Both models use graphical representations of the systems they model to make the complexity of the model easy for a human to parse, but these models can be difficult for a computer to parse. \par
UML tries to overcome this by being equally readable by a computer: frameworks like the Eclipse Modelling Framework can generate Java code from a UML class diagram, for example\cite{EMFManual}. UML also succeeds in creating a standard for colloquial "flowcharts" by creating well-defined specifications such as the UML Activity Diagram. Therefore, using UML as a format for laying out a sociotechnical system that can be easily created and read by humans, but is also easily computer-parsable, seemed to be an appropriate way to create the programmatic models.


\section{Fuzzing Library}  
\label{planning_head}
Having researched what was already available in the academic and commercial spaces, it was decided after some deliberation that the best option was to define our own modelling system and create our own fuzzing library. 

\subsection{Fuzzing Library Requirements}\label{planning_fuzzing}
The fuzzing library desired also had unique properties that made it difficult to find an equivalent for in a commercial or academic setting. \par
The fuzzing library was of particular importance because the main study of the project was on variance in sociotechnical systems. Therefore, the fuzzing library had a particularly strict set of requirements. the fuzzing library needed to have fairly precise control over the activity of the mutations, because the mutations it introduced needed to be representative of sociotechnical stress. Ideally, it would be possible that the mutation testing would not be a black box, so that the exact nature of the sociotechnical stress could be discerned. Therefore, if a custom library was not to be made, then the chosen library would need to be open sourced. \par
It transpired that the library would need to be built to spec anyway, because the library needed to generate different mutations on every call to the functions it was fuzzing. This meant that not only would specific parts of the procedural model need to be targeted, but the library would either have to intercept function calls somehow or fuzz the function to randomly select one of many fuzzed versions of itself at execution time. This functionality was \emph{critical}, because human variance in a workflow is to change the behaviour in some random way every time that behaviour is executed. With flows and atoms acting as blueprints for behaviour, these blueprints would need to be altered when enacted, just as in real life, to make a meaningful simulation. No available code fuzzing library could be found that could do fuzzing during the execution of the fuzzed program, so a custom library needed to be built. \par
With the fuzzing library being such a critical part of the research, none of these points could be compromised on. In addition, a custom built library would allow fuzzing methods to adapt and grow as the modelling method matured. Therefore, a custom fuzzing library was made. \par

\subsection{Existing Fuzzing Platforms}
\label{research_fuzzing}
Because the systems we were interested in creating were to be self-documenting, we chose Python as a language to write our models in. Python's clarity combined with the ease of quickly writing working Python code meant that self-documenting models could be feasibly made. In addition, Python supplied language features such as decorators and a built in Abstract Syntax Tree library that made it an ideal candidate. \par
We therefore set about finding appropriate fuzzing libraries in Python, and found several:
\subsubsection{Sulley}
\label{fuzzing_sulley}
Sulley is a fuzzing library for Python which is popular for remote application and protocol fuzzing. Sulley alters the protocol by which it inserts data into an application or system, and observes how that application reacts to the altered input, to simulate problems with networks and human users. It is under active development, and is open sourced.\par
While using a popular, open-source library for inspiration when creating our own mutation system, Sulley was inappropriate for our needs.\par
Sulley fuzzes by way of changing protocols and inputs to some system it interacts with. We felt that altering inputs to that system lacked the degree of control that changing workflows directly would provide. Technically, it would be possible to get around this problem by creating models in some remote program that took instructions from some fuzzed input, but we felt that this additional degree of abstraction would lower the self-documenting nature of our models and would be an impractical modelling technique anyway. \par

\subsubsection{Fusil}
\label{fuzzing_fuzil}
Fusil was another fuzzing library that was investigated. Fusil allows for fuzzing the environment of a python program, which made it appealing to us. While environmental factors impact the sociotechnical model however, these factors are unrelated to the properties Fusil is capable of monitoring. \par
Fusil is able to create mangled files as fuzzed/invalid input to a program, monitors and limits CPU and memory usage, and checks logs for system errors and other signs that a fuzzed program was not functioning correctly under adverse circumstances. This seemed appealing, because monitoring performance under adverse circumstances is precisely our goal in this project. \par
Unfortunately Fusil also did not meet our requirements: it monitors the effect of a change in computational environment on a program, where we are interested in the effect of the change of a social environment on a workflow. While our workflows are being modelled as programs, this does not mean that the workflows themselves would be being altered, so stress on a sociotechnical system still wouldn't be being modelled. Fusil was a further worse choice when taking into account the fact that we would not be able to pinpoint the errors that were being introduced by observing memory and CPU usage, and other computational concerns. \par
Therefore, we could not use Fusil as our fuzzing system of choice. \par

\subsubsection{MutPy} % Cass suggests this should be less in favour of MutPy. also, I move from a positive toa negative stance multiple times - she points out that I'd be better to stay positive then list the negative points.
\label{fuzzing_mutpy}
From the MutPy package page: %\cite{} mutpy package description at https://pypi.python.org/pypi/MutPy
\begin{displayquote}
MutPy is a mutation testing tool for Python 3.x source code. MutPy supports standard unittest module, generates YAML reports and has colorful output. It’s apply mutation on AST level. You could boost your mutation testing process with high order mutations (HOM) and code coverage analysis.
\end{displayquote}\par
It seemed that MutPy supplied \emph{everything required}. This would be beneficial, but unfortunately, MutPy had a relatively large and complex codebase that made it hard to modify for our needs. In addition, relying on a complex dependency that is designed for unit testing seemed to be a bad approach, as research interests might not align with MutPy's maintainers' in the future. As a result, it might have been necessary to fork their codebase at the time and maintain our own version for research purposes; this approach was not future-proof, and so an alternative approach was deemed necessary. \par
Working in MutPy's favour, however, was that it was a \emph{code fuzzing} rather than protocol fuzzing library. Particularly, it fuzzed source code to a similar end as something like Java's PiTest. This was more in line with our goals, although MutPy still didn't deliver what was required from a code fuzzing library for this experiment. \par%\cite{} PiTest at http://pitest.org/

\subsubsection{PyMuTester}
\label{fuzzing_pymutester}
PyMuTester proved to be the closest to the library required, though it still fell short in some areas. Particularly, PyMuTester did not appear to have many types of mutation it could enact. \par
PyMuTester did not have a large codebase, nor did it have very much functionality to offer, but it offered mutation via an Abstract Syntax Tree editing. The decision was made to study the PyMuTester source as a template for a code fuzzing library of a new design. PyMuTester seemed to be much too immature as a library to base the whole project around, and was last updated in October 2014. However, it did show promise, and gave a basis around which writing a code mutation library could be built, while also taking cues from the more advanced source of MutPy.  \par%\cite{} PyMuTester source at https://github.com/miketeo/PyMuTester       \cite{} MutPy's source at https://bitbucket.org/khalas/mutpy/src
